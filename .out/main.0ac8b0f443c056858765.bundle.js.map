{"version":3,"file":"main.0ac8b0f443c056858765.bundle.js","sources":["webpack:///./src/components/Form/utils.tsx"],"sourcesContent":["import { WrappedFormInternalProps, ValidationRule, GetFieldDecoratorOptions } from 'antd/lib/form/Form'\nimport { InnerFormProps, InnerFormTypeProps } from './InnerForm';\nimport { BooleanInput, TextInput, NumberInput, DateInput, TimeInput, EnumInput, HasOneInput } from './widgets/index';\nimport * as moment from 'moment';\nimport { InputWrapper, InputWrapperProps, validatorFunc } from './InputWrapper';\nimport * as React from 'react';\nimport { SelectFragmentProp } from './ModelFragments';\n\nexport const isFunction = (funcToCheck) => {\n  if (!funcToCheck) return false;\n  return {}.toString.call(funcToCheck) === '[object Function]';\n}\n\nconst nameToFormFieldMapping = {\n  Boolean: BooleanInput,\n  String: TextInput,\n  Datetime: TimeInput,\n  Date: DateInput,\n  Int: NumberInput,\n  BigInput: NumberInput,\n  Float: NumberInput,\n  BigFloat: NumberInput,\n}\n\nexport type PossibleTypeNames = keyof typeof nameToFormFieldMapping;\nexport function handlableTypeName(type: any): type is PossibleTypeNames {\n  if (['Boolean', 'String', 'Datetime', 'Date', 'Int', 'BigInt', 'Float', 'BigFloat'].includes(type)) {\n    return true;\n  }\n  return false;\n}\nexport interface FormFieldOptionProps {\n  customValidators?: { [x: string]: validatorFunc };\n  customRules?: { [x: string]: ValidationRule[] };\n  customDecorators?: { [x: string]: GetFieldDecoratorOptions };\n  customWidgets?: { [x: string]: React.FC<{ value: any, onChange: (p: any) => void }> };\n}\nexport interface createFormFieldsProps extends WrappedFormInternalProps<InnerFormProps>, FormFieldOptionProps, InnerFormTypeProps {\n  mapping?: { [x: string]: SelectFragmentProp };\n  instanceData: object;\n}\nexport const createFormFields: (props: createFormFieldsProps) => React.ReactNode[] = (props) => {\n  const { fields, inputFields, instanceData = {}, form, customDecorators = {},\n    customRules = {}, customValidators = {}, customWidgets = {},\n    mapping = {},\n  } = props;\n  // fields are going to be used as reference to check if it's a foreign key, let's process it once first\n  // it is a keyName => modelName mapping\n  const foreignKeys: { [x: string]: string } = {};\n  fields.forEach(f => {\n    const { name: fieldName, type: { name: typeName, kind } } = f;\n    if (kind === 'OBJECT' && fieldName.includes('By') && typeName) {\n      // It is a foreign key\n      const keyName = fieldName.substring(fieldName.indexOf('By'));\n      if (keyName) foreignKeys[keyName] = typeName;\n    }\n  })\n  return inputFields.map(field => {\n    const { name: fieldName, type } = field;\n    // Sometimes it's not null,  then have to go one level deeper\n    const info = type.kind === 'NON_NULL' ? type.ofType : type;\n    if (!info) return null;\n\n    const { kind, name: typeName } = info;\n    // Here we try to create the Form Item for this field. Have to check the type, and add extra fields etc.\n    const fieldProps: InputWrapperProps = {\n      form,\n      name: fieldName,\n      type,\n      value: instanceData[fieldName],\n      hidden: false,\n      disabled: false,\n    };\n    // Here check for some override settings\n    if (customDecorators[fieldName]) {\n      fieldProps.options = customDecorators[fieldName];\n    }\n    if (customRules[fieldName]) {\n      fieldProps.customRules = customRules[fieldName];\n    }\n    if (customValidators[fieldName]) {\n      fieldProps.validator = customValidators[fieldName];\n    }\n\n    // Based on Type\n    let value = instanceData[fieldName];\n    let toReturn: React.ReactNode = null;\n    if (customWidgets[fieldName]) {\n      // If user have provided a custom widget for this type, the use that\n      const C = customWidgets[fieldName];\n      //@ts-ignore\n      toReturn = <C />;\n    } else if (kind === 'SCALAR') {\n      if (handlableTypeName(typeName)) {\n        // It could be a foreign Key, so we do some guess here\n        if (mapping[fieldName]) {\n          // @ts-ignore\n          toReturn = <HasOneInput {...mapping[fieldName]} />\n        } else if (foreignKeys[fieldName]) {\n          // It is a foreign key by the fooByBarId pattern. \n          toReturn = <NumberInput />\n        } else {\n          const C = nameToFormFieldMapping[typeName];\n          switch (typeName) {\n            case 'Date':\n            case 'Datetime': {\n              value = value ? moment(value) : null;\n            }\n          }\n          // @ts-ignore\n          // The component here should not pass in any parameters\n          // Even though they require a non null value, onChange\n          // Because the getFieldDecorator() in form will provide it\n          toReturn = <C />;\n        }\n      } else {\n        // If it's not known, but still a scalar, then use a text input\n        toReturn = <TextInput />;\n      }\n    } else if (kind === 'ENUM') {\n      if (typeName) {\n        // @ts-ignore\n        toReturn = <EnumInput enumType={typeName} />\n      }\n    }\n    return <InputWrapper {...fieldProps} key={fieldName}>\n      {toReturn}\n    </InputWrapper>;\n\n  });\n}try {\n    // @ts-ignore\n    handlableTypeName.displayName = \"handlableTypeName\";\n    // @ts-ignore\n    handlableTypeName.__docgenInfo = { \"description\": \"\", \"displayName\": \"handlableTypeName\", \"props\": {} };\n    // @ts-ignore\n    if (typeof STORYBOOK_REACT_CLASSES !== \"undefined\")\n        // @ts-ignore\n        STORYBOOK_REACT_CLASSES[\"src/components/Form/utils.tsx#handlableTypeName\"] = { docgenInfo: handlableTypeName.__docgenInfo, name: \"handlableTypeName\", path: \"src/components/Form/utils.tsx#handlableTypeName\" };\n}\ncatch (__react_docgen_typescript_loader_error) { }try {\n    // @ts-ignore\n    isFunction.displayName = \"isFunction\";\n    // @ts-ignore\n    isFunction.__docgenInfo = { \"description\": \"\", \"displayName\": \"isFunction\", \"props\": {} };\n    // @ts-ignore\n    if (typeof STORYBOOK_REACT_CLASSES !== \"undefined\")\n        // @ts-ignore\n        STORYBOOK_REACT_CLASSES[\"src/components/Form/utils.tsx#isFunction\"] = { docgenInfo: isFunction.__docgenInfo, name: \"isFunction\", path: \"src/components/Form/utils.tsx#isFunction\" };\n}\ncatch (__react_docgen_typescript_loader_error) { }try {\n    // @ts-ignore\n    createFormFields.displayName = \"createFormFields\";\n    // @ts-ignore\n    createFormFields.__docgenInfo = { \"description\": \"\", \"displayName\": \"createFormFields\", \"props\": { \"mapping\": { \"defaultValue\": null, \"description\": \"\", \"name\": \"mapping\", \"required\": false, \"type\": { \"name\": \"{ [x: string]: any; }\" } }, \"instanceData\": { \"defaultValue\": null, \"description\": \"\", \"name\": \"instanceData\", \"required\": true, \"type\": { \"name\": \"object\" } }, \"form\": { \"defaultValue\": null, \"description\": \"\", \"name\": \"form\", \"required\": true, \"type\": { \"name\": \"WrappedFormUtils<any>\" } }, \"customValidators\": { \"defaultValue\": null, \"description\": \"\", \"name\": \"customValidators\", \"required\": false, \"type\": { \"name\": \"{ [x: string]: any; }\" } }, \"customRules\": { \"defaultValue\": null, \"description\": \"\", \"name\": \"customRules\", \"required\": false, \"type\": { \"name\": \"{ [x: string]: ValidationRule[]; }\" } }, \"customDecorators\": { \"defaultValue\": null, \"description\": \"\", \"name\": \"customDecorators\", \"required\": false, \"type\": { \"name\": \"{ [x: string]: GetFieldDecoratorOptions; }\" } }, \"customWidgets\": { \"defaultValue\": null, \"description\": \"\", \"name\": \"customWidgets\", \"required\": false, \"type\": { \"name\": \"{ [x: string]: FunctionComponent<{ value: any; onChange: (p: any) => void; }>; }\" } } } };\n    // @ts-ignore\n    if (typeof STORYBOOK_REACT_CLASSES !== \"undefined\")\n        // @ts-ignore\n        STORYBOOK_REACT_CLASSES[\"src/components/Form/utils.tsx#createFormFields\"] = { docgenInfo: createFormFields.__docgenInfo, name: \"createFormFields\", path: \"src/components/Form/utils.tsx#createFormFields\" };\n}\ncatch (__react_docgen_typescript_loader_error) { }"],"mappings":"AAEA","sourceRoot":""}